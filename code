/**
 * Simple shell interface program.
 *
 * 222017321102090-YuYiDan-project-2
 * 2019/10/01
 */

#include<stdio.h>
#include<stdlib.h>
#include<ctype.h>
#include<string.h>
#include<unistd.h>
#include<fcntl.h>
#include<sys/types.h>
#include<sys/wait.h>
#include<dirent.h>


#define MAX_LINE		80   /* 80 chars per line, per command */
#define MAX_STORE       10   /* 10 most recent commands store in history */

typedef struct historyList   /* structure used for store the history of commands */
{
	int upperH;
	int countH;
	char argsH[MAX_LINE / 2 + 1][MAX_LINE / 2 + 1];
}historyList;

char* args[MAX_LINE / 2 + 1];/* command line (of 80) has max of 40 arguments */
char input[MAX_LINE];        /* store command */
int should_run = 1;          /* flag of running*/
int upper = 0;               /* number of commands after decomposition */
int count = 0;               /* number of commands have been input */
historyList hisL[MAX_STORE]; /* history array */
int bigger = -1;             /* index of the most recent history command in array */


int analysis_command();      /* analysis command of user's input */
int find_command(char* command);/* find command */
int do_command();            /* do command */
int add_history();           /* add history */
int find_Nth(char* command); /* find the Nth command in history */
int find_mostRecent();       /* find the most recent command in history */
int get_history();           /* get history */
void init_history();         /* initialize the history struct array */
int isNum(char* command);    /* check if the command is a number */

int main()
{
	init_history();
	while (should_run)
	{
		printf("osh>");
		fflush(stdout);
		gets(input);
		if(!analysis_command())
			continue;
		add_history();
		/**
		 * After reading user input, the steps are:
		 * (1) fork a child process
		 * (2) the child process will invoke execvp()
		 * (3) if command included &, parent will invoke wait()
		 */
		do_command();

	}
	return 0;
}

/* analysis command of user's input */
int analysis_command()
{
	upper = 0;
	int flag = 0;//the location of the next copy
	for (int i = 0; i < (strlen(input) + 1); i++)
	{
		if (input[i] == ' ' || input[i] == '\0')
		{
			args[upper] = (char*)malloc((i - flag) * sizeof(char));
			if (!args[upper])
			{
				puts("Failed to create array! \n");
				exit(1);
			}
			for (int j = 0; j < (i - flag); j++)
			{
				args[upper][j] = input[j + flag];
			}
			args[upper][i - flag] = '\0';
			flag = i + 1;
			upper++;
		}
	}
	args[upper] = NULL;//add the NULL at the end of args
	/* exit the program */
	if (strcmp(args[0], "logout") == 0 || strcmp(args[0], "exit") == 0)
	{
		should_run = 0;
		for (int k = 0; k < upper; k++)
			free(args[k]);//free the memory
		return 0;
	}
	/* look up history list */
	else if (strcmp(args[0], "prompt") == 0)
	{
		if(!get_history())
			puts("Empty history");
		for (int k = 0; k < upper; k++)
			free(args[k]);//free the memory
		return 0;
	}
	/* enters !! */
	else if (strcmp(args[0], "!!") == 0)
	{
		if (!find_mostRecent())
		{
			puts("No commands in history");
			for (int k = 0; k < upper; k++)
				free(args[k]);//free the memory
			return 0;
		}
	}
	/* enters !N */
	else if (args[0][0] == '!' && isNum(args[0]))
	{
		if (!find_Nth(args[0]))
		{
			puts("No such command in history");
			for (int k = 0; k < upper; k++)
				free(args[k]);//free the memory
			return 0;
		}
		
	}
	/*judge whether the command exists*/
	else if (!find_command(args[0]))
	{
		puts("error: Can't find command");
		for (int k = 0; k < upper; k++)
			free(args[k]);//free the memory
		return 0;
	}
	return 1;
}

/* find command */
int find_command(char* command)
{
	DIR* d;
	struct dirent* ptr;
	char temp[100];
	char* dir;
	/* acquire the environment variables */
	char* path = getenv("PATH");
	/* separate environment variables, and then look up each directory to see if the command exists*/
	strcpy(temp, path);
	dir = strtok(temp, ":");
	while (dir) {
		d = opendir(dir);
		while ((ptr = readdir(d)) != NULL)
			if (strcmp(ptr->d_name, command) == 0) {
				closedir(d);
				return 1;
			}
		closedir(d);
		dir = strtok(NULL, ":");
	}
	return 0;
}

/* do command */
int do_command()
{
	int back_run = 0; /* flag of child process run in the background */
	if (strcmp(args[upper - 1], "&") == 0)
	{
		back_run = 1;
		args[upper - 1] = NULL;
	}
	/* fork a child process */
	pid_t pid;
	pid = fork();
	if (pid < 0) 
	{
		perror("fork error");
		exit(0);
	}
	else if (pid == 0)/* child process */
	{
		execvp(args[0], args);
	}
	else/* parent process */
	{
		if (!back_run)/* parent needs to wait for child exit if the child doesn't run in background */
		{             /* it means that parent and child will work concurrently if child run in background */
			waitpid(pid, NULL, 0);
		}
	}
	for (int k = 0; k < upper; k++)
		free(args[k]);//free the memory
	return 0;
}

/* add history */
int add_history()
{
	count++;
	if (bigger >= -1 && bigger < (MAX_STORE - 1))
	{
		bigger++;
		for (int j = 0; j < upper; j++)
			strcpy(hisL[bigger].argsH[j], args[j]);
		hisL[bigger].countH = count;
		hisL[bigger].upperH = upper;
		//printf("-----------------------------------bigger%d\n", bigger);
		//printf("-----------------------------------upper%d\n", upper);
	}
	else
	{
		for (int i = 1; i < MAX_STORE; i++)
		{
			for (int j = 0; j < hisL[i - 1].upperH; j++)
				hisL[i - 1].argsH[j][0] = '\0';/* delete the oldest command */
			for (int m = 0; m < hisL[i].upperH; m++)
				strcpy(hisL[i - 1].argsH[m], hisL[i].argsH[m]);/* move forward one step */
			hisL[i - 1].countH = hisL[i].countH;
			hisL[i - 1].upperH = hisL[i].upperH;
		}
		for (int k = 0; k < hisL[MAX_STORE - 1].upperH; k++)
			hisL[MAX_STORE - 1].argsH[k][0] = '\0';
		for (int j = 0; j < upper; j++)
			strcpy(hisL[MAX_STORE - 1].argsH[j], args[j]);
		hisL[MAX_STORE - 1].countH = count;
		hisL[MAX_STORE - 1].upperH = upper;
	}
	return 0;
}

/* find the most recent command in history */
int find_mostRecent()
{
	if (hisL[0].upperH == 0)/* history is empty */
		return 0;
	for (int j = 0; j < upper; j++)
		free(args[j]);
	for (int i = 0; i < hisL[bigger].upperH; i++)/* change command to the most recent command in the history */
	{
		args[i] = (char*)malloc((strlen(hisL[bigger].argsH[i])) * sizeof(char));
		strcpy(args[i], hisL[bigger].argsH[i]);
	}
	upper = hisL[bigger].upperH;
	args[upper] = NULL;
	return 1;
}

/* find the Nth command in history */
int find_Nth(char* command)
{
	char temp1[MAX_LINE / 2 + 1];
	for (int j = 1; j < strlen(command); j++)
	{
		temp1[j - 1] = command[j];
	}
	int temp2 = atoi(temp1);/* change string to int*/
	for (int i = 0; i < MAX_STORE; i++)
	{
		if (temp2 == hisL[i].countH)
		{
			for (int m = 0; m < upper; m++)
				free(args[m]);
			for (int k = 0; k < hisL[i].upperH; k++)
			{
				args[k] = (char*)malloc((strlen(hisL[i].argsH[k])) * sizeof(char));
				strcpy(args[k], hisL[i].argsH[k]);/* change command to the Nth command in the history */
			}
			upper = hisL[i].upperH;
			args[upper] = NULL;
			return 1;
		}
	}
	return 0;
}

/* get history */
int get_history()
{
	if (hisL[0].argsH[0][0] == '\0')
		return 0;
	int i = 0;
	while(hisL[i].countH != 0)
	{
		printf("%d ", hisL[i].countH);
		for (int j = 0; j < hisL[i].upperH; j++)
		{
			printf("%s ", hisL[i].argsH[j]);
		}
		i++;
		printf("\n");
	}
	return 1;
}

/* initialize the history struct array */
void init_history()
{
	for (int i = 0; i < MAX_STORE; i++)
	{
		hisL[i].countH = 0;
		hisL[i].upperH = 0;
		for (int j = 0; j < (MAX_LINE / 2 + 1); j++)
			hisL[i].argsH[j][0] = '\0';
	}
}

/* check if it is a number */
int isNum(char* command)
{
	for (int i = 1; i < strlen(command); i++)
	{
		if (!isdigit(command[i]))
			return 0;
	}
	return 1;
}
